#include <linux/mm_types.h>
/*
struct page
struct vma_struct
*/

#include <linux/mm.h>
/*
page_address()
page protection bit definitions e.g. VM_READ
remap_pfn_range()
*/

#include <linux/gfp.h>
/*
alloc_pages()
flags associated with alloc_pages
__free_pages
*/

#include "LAMbS_models.h"
#include "LAMbS_VICtimer.h"

struct  page    *LAMbS_models_pages = NULL;

/*The retirement rate and inverse retirement rates accross all MOs*/
u64 *instruction_retirement_rate;
u64 *instruction_retirement_rate_inv;
u64 *om_schedule;

/*Current moi, retirementrate, returementrate_inv*/
u64 LAMbS_current_instretirementrate;
u64 LAMbS_current_instretirementrate_inv;

/*
This function is called because current model coefficients have changed either due to 
change in the cirrent mode of operation or an update to the model coefficients

This function should be called with interrupts disabled
*/
void    _LAMbS_models_motrans_callback(  
                                struct LAMbS_motrans_notifier_s *motrans_notifier_p,
                                s32 old_moi,    s32 new_moi)
{    
    LAMbS_current_instretirementrate = 
                            instruction_retirement_rate[new_moi];
    LAMbS_current_instretirementrate_inv = 
                            instruction_retirement_rate_inv[new_moi];

    LAMbS_VICtimer_motransition();
}

/*
Define a notifier_block varriable with LAMbS_update_current_instrate as the callback 
function
*/
struct LAMbS_motrans_notifier_s LAMbS_models_motrans_notifier;

/*Initialize the model coefficients and current instruction retirement rate and 
corresponding inverse
*/
void LAMbS_models_init(void)
{
    s32 moi;
    unsigned long irq_flags;
    
    local_irq_save(irq_flags);

        for(moi = 0; moi < LAMbS_mo_struct.count; moi++)
        {
            /*Initialize all instruction retirement rates to 1*/
            instruction_retirement_rate[moi] = ((u64)1 << LAMbS_MODELS_FIXEDPOINT_SHIFT);
            instruction_retirement_rate_inv[moi] = ((u64)1 << LAMbS_MODELS_FIXEDPOINT_SHIFT);
            om_schedule[moi] = 0;
        }
        
        LAMbS_current_instretirementrate = 
                                instruction_retirement_rate[LAMbS_current_moi];
        LAMbS_current_instretirementrate_inv = 
                                instruction_retirement_rate_inv[LAMbS_current_moi];

    local_irq_restore(irq_flags);
}

/*
    - Allocate pages for the model coefficients.
    - Setup the coefficients arrays.
    - Initialize the coefficients arrays.
    - Register the motrans notifier object.
        - The motrans callback function, "LAMbS_update_current_instrate", calls the 
          VICtimer callback function. Therefore the LAMbS_VICtimer_mechanism_init should 
          be called before LAMbS_models_alloc_pages.
*/
int LAMbS_models_alloc_pages(void)
{
    int ret;
    
    int LAMbS_models_size = LAMbS_mo_struct.count * 3 * sizeof(u64);
    
    if(LAMbS_MODELS_SIZE < LAMbS_models_size)
    {
        printk(KERN_INFO "LAMbS_models_alloc_pages: Given current limitations of the "
                        "kernel module, the number of modes of operation are too many!");
        ret = -EINVAL;
        goto error0;
    }
    
    //allocate pages (not in high memory)
    LAMbS_models_pages = alloc_pages(   (__GFP_WAIT | __GFP_REPEAT |  __GFP_ZERO), 
                                        LAMbS_MODELS_ORDER);
    if(NULL == LAMbS_models_pages)
    {
        printk(KERN_INFO "LAMbS_models_alloc_pages: alloc_pages failed for "
                        "LAMbS_models_pages");
        ret = -ENOMEM;
        goto error0;
    }

    if(NULL == page_address(LAMbS_models_pages))
    {
        //the allocated memory is in high memory, which is bad for us
        printk(KERN_INFO "LAMbS_models_alloc_pages: The LAMbS_models_pages are in high "
                        "memory!\n");
        ret = -ENOMEM;
        goto error1;
    }

    /*Setup the arrays*/
    instruction_retirement_rate = (u64*)page_address(LAMbS_models_pages);
    instruction_retirement_rate_inv = &(instruction_retirement_rate[LAMbS_mo_struct.count]);
    om_schedule = &(instruction_retirement_rate_inv[LAMbS_mo_struct.count]);

    /*Initialize the arrays.*/
    LAMbS_models_init();
    
    /*Register the motrans notifier*/
    LAMbS_models_motrans_notifier.callback = _LAMbS_models_motrans_callback;
    LAMbS_motrans_register_notifier(&(LAMbS_models_motrans_notifier));
    
    return 0;
    
error1:
    __free_pages(LAMbS_models_pages, LAMbS_MODELS_ORDER);
    LAMbS_models_pages = NULL;
error0:
    return ret;
}

/*Do any processing necessary on the omschedule generated by the
allocator. This may involve sanitizing the schedule so that the
time spent in any OM is not less than the transition time*/
void LAMbS_models_process_omschedule(void)
{
    
}

void LAMbS_models_free_pages(void)
{
    /*Unregister the motrans_notifier object*/
    LAMbS_motrans_unregister_notifier(&(LAMbS_models_motrans_notifier));

    /*Set all the array addresses to NULL*/
    instruction_retirement_rate = NULL;
    instruction_retirement_rate_inv = NULL;
    om_schedule = NULL;
    
    /*Free the page frames, set the page frame pointer to NULL*/
    __free_pages(LAMbS_models_pages, LAMbS_MODELS_ORDER);
    LAMbS_models_pages = NULL;
}

